=== The Domain Model

Our task is to build an event registration application that allows people to register for events using their name. Before we can program anything we need to model the application. 

For this, use the free modelling program link:https://cruise.umple.org/umpleonline/[Umple]. Full documentation on how to use Umple can be found link:https://cruise.umple.org/umple/GettingStarted.html[here].

Ensure that Umple is configured as shown in the image below:

image::UmpleConfig.png[]

Our task for this tutorial will be to create a simple event registration application that allows people to sign up and register for events. 

Readily obvious is the need for a class to hold information about people and events. As people register for events, these two classes will need to be associated.

Naively we may want to come up with a domain model that looks something like the image below: 

image::NaiveUML1.PNG[align="center"]

There are numerous problems with this scheme. Some are listed below in order of severity:

1. There is no constraint on this association. In best practice, we avoid unconstrained associations for security and cohesive behaviour reasons. To ensure our application code can only be used in the intended fashion, we must constrain all relationships between entities. In this case, there is no practical reason for events (E) and person (P) to be aware of each other. One needs to be independent.
2. We can have arbitrarily many events or people registering for events. Even when the association is constrained to a single direction, person or events will have to hold an array of events or persons respectively. Storing arbitrarily large arrays when using a SQL based database is heavily discouraged. To keep this same domain model and avoid storing variable size elements such as arrays, we would need to duplicate information about event or person.
3. Even when the association is constrained to a single direction, our multiplicities allow for an optional association. This might be desired behaviour (i.e. people should be able to exist in our application without an event and vice versa), but it allows for an optional association. This is not bad but it is not good practice. 

To remedy these problems, we introduce an association class called _registration_ \(R) which will be associated with both Person and Event. We will also constrain these associations by making them unidirectional and necessitating that one and only one instance of person and one and only one instance of event must be associated with a registration. Simply, a regitration can only hold information about one person and one event. In this way it mediates the relationship between people and the events they register for. 

image::BetterUML1.PNG[align="center"]

It may appear that registrations for events can still be duplicated (i.e. Someone can register for the same event tiwce). Addressing this concern depends on how databasing is implemented. For some implementations, the combination of a unique identifier for person and a unique identifier for event forms a unique identifier for registration. So, if a person tries to register for an event twice, the database will throw an error. In other implementations, this may not be the case as registration will be given a unique id. In this case preventing duplication is delegated to code. 

The final model can be found below and is generated by the following code:

image::DomainModel.PNG[]

[source,Umple]
----
class RegistrationManager
{
}

class Person
{
  name;
}

class Event
{
  name;
  Date eventDate;
  Time startTime;
  Time endTime;
}

class Registration
{
  Integer id;
  }

association {
    1 RegistrationManager registrationManager <@>- 0..* Registration registrations;
}

association {
    1 RegistrationManager registrationManager <@>- 0..* Event events;
}

association {
    1 RegistrationManager registrationManager <@>- 0..* Person persons;
}

association {
   0..* Registration registration ->  1 Event event ;
}


association {
    0..* Registration registration ->  1 Person person;
}
----

Finally, we generate Java code by clicking the *Generate Java* button. Although the Umple generated Java code can be used, but is too verbose and not JPA compliant. You can see this by comparing the generated Java code to the code found in link:https://github.com/McGill-ECSE321-Fall2020/ecse321-tutorial-notes/raw/master/resources/Model%20Classes.zip[Model Classes.zip].

=== JPA Annotations

Next we will create a gradle project  following the steps given in *Section 1.1*. Your project structure should look like this.

[source,none]
----
EventRegistration-Backend
├── build.gradle
├── settings.gradle
└── src
    ├── main
    │   ├── java
    │   │   └── ca\mcgill\ecse321\eventregistration
    │   │        └── EventRegistrationApplication.java
    │   └── resources
    │       └── application.settings
    │
    └── test
        └── java
            └── ca\mcgill\ecse321\eventregistration
                └── EventRegistrationApplicationTests
----


This is an exercise in being able to write JPA compliant code simply by looking at the domain model. A brief explanation for relevant JPA tags is here provided:

* *@Entity*: Placed before the class declaration to signify an entity.
* *@Id*: Placed before the get method for the attribute that will serve as the primary identifier for the class.
* *@OnetoMany* or *@ManytoOne*: Placed before get method for attribute to signify the multiplicity in associative relationship between the current class and reference class. The first word is the multiplicity of the current class, with the other representing the multiplicity of the other calss. The _cascade_ property being set to _cascadeType.ALL_ ensures all operations of the defining class are persisted. The _optional_ property being set to false means the association the tag defines must exist. In this case, the defining class cannot exist without knowledge of the referenced class. 

Once your java code has been annotated, create a new folder under _src>main>java_ called model and add the model files into that folder. Each class in our domain model should have its own file. Make sure your model files declare the package:

[source,java]
----
package ca.mcgill.ecse321.eventregistration.model;
----

Your folder structure should now look like this:

[source,none]
----
EventRegistration-Backend
├── build.gradle
├── settings.gradle
└── src
    ├── main
    │   ├── java
    │   │   └── ca\mcgill\ecse321\eventregistration
    │   │        ├── EventRegistrationApplication.java
    │   │        └── model
    │   │            ├── Event.java
    │   │            ├── Person.java
    │   │            ├── Registration.java
    │   │            └── RegistrationManager.java
    │   └── resources
    │       └── application.settings
    │
    └── test
        └── java
            └── ca\mcgill\ecse321\eventregistration
                └── EventRegistrationApplicationTests
----
